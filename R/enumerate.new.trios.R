#'
#' @name enumerate.new.trios
#' @title Form trios involving genetic variants
#' @description Given some already analysed trios, enumerate new trios involving
#' genetic variants. Not a user level function.
#'
#' @export enumerate.new.trios
#'
#' @param trio.set \eqn{n \times 3} matrix of \eqn{n} already analysed trios.
#' Each row of \code{trio.set} is a vector giving the labels of a genetic variant
#' (\code{V}-node), and two genes (\code{T}-nodes).
#'
#' @param new.edges logical \eqn{n} vector, the \code{i}th element indicating the
#' presence/absence of a new edge in the trio at the \code{i}th row of \code{trio.set}.
#'
#' @param old.adjacency Adjacency matrix used to form trios in \code{trio.set}.
#'
#' @param adjacency Updated adjacency matrix after the analysis of trios in \code{trio.set}.
#'
#' @param n_v,n_t,n_q Numbers of respectively \code{V,T,Q}-nodes in \code{adjacency}. I.e.,
#' the first \code{n_v} columns/rows of \code{adjacency} correspond to \code{V}-nodes,
#' the next \code{n_t} columns/rows correspond to \code{T}-nodes, and the last
#' \code{n_q} columns/rows correspond to \code{Q}-nodes.
#'
#' @param VTT logical indicating the composition of desired trios. If true (the default),
#' only trios not involving a \code{Q}-node are formed, i.e. a trio contains one
#' \code{V}-node and two \code{T}-nodes. Otherwise, only trios involving
#' \code{Q}-nodes are formed, i.e. a trio contains one \code{V}-node,
#' one \code{T}-node, and one \code{Q}-node.
#'
#' @param Qtrio.set \eqn{m \times 3} matrix of \eqn{m} already analysed trios
#' with \code{Q}-nodes. Each row of \code{trio.set} is a vector giving the labels
#' of a genetic variant (\code{V}-node), one genes (\code{T}-node), and one common
#' child or intermediate (\code{Q}-node). Used when \code{VTT = FALSE} to sort
#' out any previously analysed trio from the return output.
#'
#' @param cl a cluster object, created by one of the packages \code{parallel} and \code{snow}.
#' Specify \code{cl = NULL} for no parallel computation. Note that this is not the
#' genuine default. If missing, the registered default cluster (which can be
#' \code{NULL}, but may not be) is considered.
#'
#' @param chunk.size integer, number of tasks per scheduling unit during parallel computation.
#'
#' @return An \eqn{K \times 3} matrix of \eqn{K} trios. Each row gives the
#' column numbers of variables forming a trio, the first giving the genetic
#' variant (\code{i}), and the last two giving phenotypes, named 'Tj', 'Tk'
#' when \code{VTT = TRUE}, and named 'Tj', Qk' when \code{VTT = FALSE}.
#' If no additional trio can be formed, the returned matrix has zero row.
#'
#' @seealso \link{enumerate.trios} to form trios when none has been yet analysed.
#'
# enumerate.new.trios (trio.set,
#                      new.edges,
#                      old.adjacency,
#                      adjacency,
#                      n_v, n_t,
#                      n_q = NROW(adjacency) - n_t - n_v,
#                      VTT = TRUE,
#                      Qtrio.set = NULL,
#                      cl,
#                      chunk.size = NULL)
#
#
#'
# Internal routine
# List new trios based on new edges added into a network (using a prior 'trio analysis')
enumerate.new.trios <- function (trio.set,   # n x 3 matrix of n already analysed trios (in which new edges were added or not)
                                 new.edges,  # logical vector indicating presence of a new edge in each trio in \code{trio.set}
                                 old.adjacency,    # old adjacency matrix
                                 adjacency,        # new adjacency matrix
                                 n_v, n_t,   # numbers of V-nodes and T-nodes, respectively
                                 n_q = NROW(adjacency) - n_t - n_v, # Number of Q-nodes
                                 VTT = TRUE, Qtrio.set = NULL,
                                 cl,
                                 chunk.size = NULL) {
  # No new trio generated if no new edge OR (VTT = FALSE but n_q = 0)
  if (!any(new.edges) | (!VTT[1] & n_q == 0)) {
    return(matrix(0, ncol = 3, nrow = 0))
  }

  # Extract the set of trios with newly added edges
  subtrio.set <- trio.set[new.edges,, drop = FALSE]

  # Find additional trios generated by the new edge
  if (missing(cl))
    cl <- parallel::getDefaultCluster()
  n_vt <- n_v + n_t
  new.trio.set <- matteApply(subtrio.set, MARGIN = 1,
                             FUN = enumerate.new.trios.i,
                             adjacency = adjacency,
                             old.adjacency = old.adjacency,
                             Vlabels = 1:n_v, # Labels (numbers) for all V-nodes
                             Tlabels = (1 + n_v):n_vt, # Labels (numbers) for all T-nodes
                             Qlabels = if (n_q > 0) (1 + n_vt):(n_vt + n_q),
                             VTT = VTT[1],
                             chunk.size = chunk.size,
                             simplify = FALSE,
                             cl = cl)
  new.trio.set <- do.call('rbind', new.trio.set)
  if (is.null(new.trio.set)) { # no new trio generated by the new edge
    return(matrix(0, ncol = 3, nrow = 0))
  }
  else {
    new.trio.set <- unique(new.trio.set) # trios generated by the new edges
    if (VTT[1]) {
      set0 <- trio.identifyer(trio.set) # unique identifiers for already analysed trios
      set1 <- trio.identifyer(new.trio.set) # unique identifiers for new trios
      keep <- !is.element(set1, set0) # keep only new trios
      new.trio.set <- new.trio.set[keep, , drop = FALSE]
    }
    else if (!is.null(Qtrio.set)) {
      set0 <- trio.identifyer(Qtrio.set) # unique identifiers for already analysed trios
      set1 <- trio.identifyer(new.trio.set) # unique identifiers for new trios
      keep <- !is.element(set1, set0) # keep only new trios
      new.trio.set <- new.trio.set[keep, , drop = FALSE]
    }

    row.names(new.trio.set) <- NULL
    return(new.trio.set)
  }
}

# Child function for 'enumerate.new.trios'
enumerate.new.trios.i <- function(col.indices,
                                  adjacency,
                                  old.adjacency,
                                  Vlabels,
                                  Tlabels,
                                  Qlabels,
                                  VTT) {
  old.Aijk <- old.adjacency[col.indices, col.indices]
  Aijk <- adjacency[col.indices, col.indices]
  # Determine if the new edge is V -- T or T -- T and find new possible trios
  if (Aijk[1,2] - old.Aijk[1,2] > 0) { # When V --> T1 is the new edge
    if (VTT) { # If trios without Q-node are desired
      # Find trios of the form T3 <-- V --> T1
      Tlabelk <- adjacency[col.indices[1], Tlabels] > 0    # T nodes linked to V
      Tlabelk <- Tlabels[Tlabelk]                    # Replace logicals by labels
      Tlabelk <- setdiff (Tlabelk, col.indices[-1])  # Exclude T1 and T2
      res <- if (length(Tlabelk)) {
        cbind(Vi = col.indices[1], Tj = col.indices[2], Tk = Tlabelk)
      }
      # Find trios of the form V --> T1 -- T3
      Tlabelk <- (adjacency[col.indices[2], Tlabels] +
                    adjacency[Tlabels, col.indices[2]]) > 0 # T nodes linked to T1
      Tlabelk <- Tlabels[Tlabelk]                     # Replace logicals by labels
      Tlabelk <- setdiff (Tlabelk, col.indices[3])    # Exclude T2
      res <- rbind(res, if (length(Tlabelk)) {
        cbind(Vi = col.indices[1], Tj = col.indices[2], Tk = Tlabelk)
      })
    }
    else { # If trios with Q-node are desired
      # Find trios of the form V --> T1 -- Q
      Qlabelk <- (adjacency[col.indices[2], Qlabels] +
                    adjacency[Qlabels, col.indices[2]]) > 0 # Q nodes linked to T1
      Qlabelk <- Qlabels[Qlabelk]                     # Replace logicals by labels
      res <- if (length(Qlabelk)) {
        cbind(Vi = col.indices[1], Tj = col.indices[2], Qk = Qlabelk)
      }
    }
    res <- unique(res)
  }
  else if (Aijk[1,3] - old.Aijk[1,3] > 0)  { # When V --> T2 is the new edge
    if (VTT) { # If trios without Q-node are desired
    # Find trios of the form T3 <-- V --> T2
    Tlabelk <- adjacency[col.indices[1], Tlabels] > 0    # T nodes linked to V
    Tlabelk <- Tlabels[Tlabelk]                    # Replace logicals by labels
    Tlabelk <- setdiff (Tlabelk, col.indices[-1])  # Exclude T1 and T2
    res <- if (length(Tlabelk)) {
      cbind(Vi = col.indices[1], Tj = col.indices[3], Tk = Tlabelk)
    }
    # Find trios of the form V --> T2 -- T3
    Tlabelk <- (adjacency[col.indices[3], Tlabels] +
                  adjacency[Tlabels, col.indices[3]]) > 0 # T nodes linked to T2
    Tlabelk <- Tlabels[Tlabelk]                     # Replace logicals by labels
    Tlabelk <- setdiff (Tlabelk, col.indices[2])    # Exclude T1
    res <- rbind(res, if (length(Tlabelk)) {
      cbind(Vi = col.indices[1], Tj = col.indices[3], Tk = Tlabelk)
    })
    }
    else {# If trios with Q-node are desired
      # Find trios of the form V --> T2 -- Q
      Qlabelk <- (adjacency[col.indices[3], Qlabels] +
                    adjacency[Qlabels, col.indices[3]]) > 0 # Q nodes linked to T1
      Qlabelk <- Qlabels[Qlabelk]                     # Replace logicals by labels
      res <- if (length(Qlabelk)) {
        cbind(Vi = col.indices[1], Tj = col.indices[3], Qk = Qlabelk)
      }
    }
    res <- unique(res)
  }
  else { # When T1 -- T2 is the new edge
    if (VTT) {# If trios without Q-node are desired
    if (Aijk[2,3] + Aijk[3,2] == 2) { # If the new edge is undirected
      # Find all V nodes linked to T1 or T2
      Vlabelk <- (adjacency[Vlabels, col.indices[2]] +
                    adjacency[Vlabels, col.indices[3]]) > 0 # V nodes linked to T1 or T2
      Vlabelk <- Vlabels[Vlabelk]                    # Replace logicals by labels
      Vlabelk <- setdiff (Vlabelk, col.indices[1])   # Exclude Vi
      res <- if (length(Vlabelk)) {
        cbind(Vi = Vlabelk, Tj = col.indices[2], Tk = col.indices[3])
      }
    }
    else { # If the edge is directed,
      # Find all V nodes only linked to either T1 or T2 (not both)
      Vlabelk <- (adjacency[Vlabels, col.indices[2]] +
                    adjacency[Vlabels, col.indices[3]]) == 1 # V nodes linked to T1 or T2
      Vlabelk <- Vlabels[Vlabelk]                    # Replace logicals by labels
      Vlabelk <- setdiff (Vlabelk, col.indices[1])   # Exclude Vi
      res <- if (length(Vlabelk)) {
        cbind(Vi = Vlabelk, Tj = col.indices[2], Tk = col.indices[3])
      }
    }
    }
    else {# If trios with Q-node are desired
      res <- NULL # A new T-T edge does not prompt a new V-T-Q trio
    }
  }
  return(res)
}

# Generate unique identifiers for trios
trio.identifyer <- function(trioset) {
  # order T1 and T2
  trioset[,2:3] <- t(apply(trioset[,2:3, drop = FALSE], MARGIN = 1, FUN = sort))
  # Generate IDs
  paste0(trioset[,1], '.', trioset[,2], '.', trioset[,3])
}
