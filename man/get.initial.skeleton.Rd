% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get.initial_skeleton.R
\name{get.initial.skeleton}
\alias{get.initial.skeleton}
\title{Build the input graph for MRGN inference}
\usage{
get.initial.skeleton(
  data,
  n_v,
  n_t,
  threshold_v = 0.2,
  threshold_m = 0.05,
  conf.sets = NULL
)
}
\arguments{
\item{conf.sets}{an optional object of class \code{conf.sets} as returned by
\link{get.conf.sets}.}
}
\value{
an object of class \code{adjacency.matrix}, i.e. a binary square matrix
with \code{n_v + n_t + n_q} columns, with only zeros on the main diagonal.

The number \code{n_q} of intermediate variables and common children is taken
from the argument \code{conf.sets} as \code{n_q = length(conf.sets$WZindices)}.
If \code{conf.sets = NULL}, then \code{n_q = 0}.
}
\description{
Build an undirected adjacency matrix for a genomic network using a dataset
where rows are individuals and columns are nodes including \code{n_v} variants
(\code{V}-nodes), \code{n_t} phenotypes (\code{T}-nodes), and \code{n_c}
candidate confounding variables (\code{C}-nodes).
}
\details{
This function implements \code{Step 2} of the MRGN general algorithm.
}
\examples{
#Raw data (networkA11) & confounding variable selection result (confsetsA11)
library(MRGNgeneral)
data(networkA11)
data(confsetsA11)

# Generate the input graph
Adjacency0 <- get.initial.skeleton (data = networkA11$data,
                                    n_v = networkA11$dims$n_v,
                                    n_t = networkA11$dims$n_t,
                                    threshold_v = 0.2,
                                    threshold_m = 0.05,
                                    conf.sets = confsetsA11)

Adj0.mtx <- Adjacency0
class (Adj0.mtx) <- "matrix"
dim (Adj0.mtx)
# 333 333
# Nodes here are V and T nodes, plus the inferred Q nodes.
# They are a subset of all the nodes.

# The true adjacency matrix does not include the independent variables
dim (networkA11$adjacency)
# 500 500

# In order to extract the corresponding nodes from the true adjacency matrix,
# need to create the adj mtx for all nodes,
# and then extract the nodes in query mtx
n_all <- sum (unlist(networkA11$dims))
true_adj_all <- matrix(0, nrow = n_all, ncol = n_all)
n_vtwzu <- nrow(networkA11$adjacency)
true_adj_all[1:n_vtwzu, 1:n_vtwzu] <- networkA11$adjacency
dim (true_adj_all)
# 600 600

# The nodes in Adjacency0
n_v <- networkA11$dims$n_v
n_t <- networkA11$dims$n_t
index_all <- c(1:(n_v+n_t), confsetsA11$WZindices)
# Extract these nodes from the entire true adjacency matrix
true_adj <- true_adj_all[index_all, index_all]

# Recall and precision of the skeleton
Recall_Precision <- RecallPrecision(as (true_adj, 'graphNEL'),
                                    as (Adj0.mtx, 'graphNEL'),
                                    GV = networkA11$dims$n_v,
                                    includeGV = TRUE,
                                    edge.presence = 1.0,
                                    edge.direction = 0.5)

}
