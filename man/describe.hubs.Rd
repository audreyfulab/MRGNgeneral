% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/describe.hubs.R
\name{describe.hubs}
\alias{describe.hubs}
\title{Empirical assessment of hubs in inferred graphs}
\usage{
describe.hubs(
  adjacency,
  n_v = 0,
  n_t = NCOL(adjacency),
  n_q = NCOL(adjacency) - (n_t + n_v),
  n_u = NCOL(adjacency) - (n_t + n_v + n_q),
  data,
  conf.sets,
  inferred.adjacency,
  number.parents = if (all.conditions) 0 else Inf,
  number.children = if (all.conditions) 0 else Inf,
  number.neighbors = 10,
  only.T = TRUE,
  all.conditions = FALSE,
  method = c("pearson", "kendall", "spearman"),
  combine.nodes = c("mean", "max"),
  combine.hubs = c("mean", "max", "largest"),
  neighbors = c("all", "parents", "children"),
  verbose = TRUE,
  cl = NULL,
  chunk.size = NULL,
  ...
)
}
\arguments{
\item{adjacency}{numeric (binary) matrix, adjacency matrix of a DAG. The nodes
must be ordered such that the first \code{n_v} columns of \code{adjacency} are variants,
the next \code{n_t} columns are phenotypes, the next \code{n_q} columns are
intermediate variables or common children, and the next \code{n_u} columns (if any) are confounders.

Note that \code{adjacency} must be square, binary with only zeros on the main diagonal.
Only the first \code{n_v+n_t+n_q+n_u} rows and columns are used.}

\item{n_v, n_t, n_q, n_u}{integers, describe the types of nodes in the network
numbers of variants (\code{V}-nodes), phenotypes (\code{T}-nodes),
intermediate variables/common children (\code{Q}-nodes), and confounders (\code{U}-nodes).}

\item{data}{\code{data.frame} object with a random sample for each node in
the network \code{adjacency} matrix to be used to describe the network.}

\item{number.parents, number.children, number.neighbors}{integer arguments used to define a hub. See \link{find.hubs}.}

\item{only.T, all.conditions}{logical arguments used to define a hub. See \link{find.hubs}.}

\item{method}{either a \code{character} or a \code{function} indicating the
association measure to use. When \code{method} is a character, One of "pearson"
(default), "kendall", or "spearman" (can be abbreviated). A function \code{method}
must take in an input matrix \code{x} and return a corresponding partial
correlation matrix. Note that only the absolute value of the results are used.}

\item{combine.nodes}{a function or a character giving the name of a function
(e.g. \code{combine.hubs} = 'mean') to be used to combine signals (absolute
association measures) over parent or child \code{T}-nodes (of a hub), if many.}

\item{combine.hubs}{character or function, either \code{'largest'} (for computing the association
measures for the largest hub), a function or the name of a function (e.g. \code{combine.hubs} = 'mean')
to be used to combine signals over hubs, if many.}

\item{neighbors}{character, when \code{combine.hubs = 'largest'} (otherwise
ignored), which neighbors are to be considered to select the largest hub?
One of \code{'parents'}, \code{'children'} and \code{all} (i.e. parents and
children).}

\item{verbose}{logical, should warning messages from running \code{method} be
allowed? Defaults to \code{TRUE}.}

\item{cl, chunk.size}{optional arguments for parallel computing, passed to
\link[parallel]{parLapply} (when supplied).}
}
\value{
An object of class \code{'summary.hubs'} which is a list with the following elements:
\describe{
\item{measure}{ a numeric 10-element vector: column wise combinations of the
\code{raw.measures} matrix. The combination of the elements of a column of
\code{raw.measures} uses the function specified by the argument \code{combine.hubs}.}
\item{raw.measure}{ Either a numeric 10-column matrix with each row giving the
equivalent of \code{measure} per hub, or \code{NULL} when no hub is found or
when \code{combine.hubs = 'largest'} (see Section 'Details' for more on
\code{raw.measures}).}
\item{number.parents}{ a numeric vector with length the number of rows of \code{raw.measure},
giving the number of parent \code{T}-nodes for each found hub, or \code{NA} if no hub was found.}
\item{number.parents}{ a numeric vector with length the number of rows of \code{raw.measure},
giving the number of child \code{T}-nodes for each found hub, or \code{NA} if no hub was found.}
\item{hubs}{ an object of class \code{'hubs'} as returned by \link{find.hubs}.}
\item{call}{ the matched call to \code{describe.hubs}.}
}

The class\code{'summary.hubs'} has a \code{print} method which shows a summary
of hubs' association with their neighbors, and recall and precision of
confounder selection and network inference.
}
\description{
Empirical description of hubs in inferred graph with known adjacency.
The function find hubs in a Direct Acyclic Graph (DAG), describe their correlation
structure based on a random sample for each node in the network, and summarize
confounder selection and network inference results for the hubs.
}
\details{
The function \code{describe.hubs} finds hub \code{T}-nodes in the true network
(by passing \code{adjacency} to \link{find.hubs}), and then computes for each hub:
\itemize{
\item the strength of the signal from parent \code{T}-nodes,
typically absolute Pearson's partial correlation to each parent \code{T}-node, given
all parents of the hub (including other \code{T}-nodes, parent \code{V} and
\code{U}-nodes), and then average them over the parents, if many ( \emph{i}- \code{Parent.cor});
\item the strength of the signal from parent \code{T}-nodes
to each parent given the set of selected confounders for the hub (including
selected \code{V} and \code{T}-nodes, and \code{C}-nodes selected as
\code{U}-nodes), and then average them over the parents, if many ( \emph{ii}- \code{Parent.cor.hat});
\item the strength of the signal to each child \code{T}-node
given all other parents of the child (including other \code{T}-nodes, parent \code{V} and
\code{U}-nodes), and then average them over the child \code{T}-nodes, if many ( \emph{iii}- \code{Child.cor});
\item the strength of the signal to each child \code{T}-node
given the union of the sets of selected confounders for the hub and its child,
and then average them over the child \code{T}-nodes, if many ( \emph{iv}- \code{Child.cor.hat});
\item recall and precision of confounder selection
(considering the set of true parent \code{V}, \code{T} and \code{U}-nodes as
the truth) ( \emph{v}- \code{conf.rec} and \emph{vi}- \code{conf.pre});
\item the recall of parent \code{T}-nodes, and the
related precision ( \emph{vii}- \code{Parent.rec} and \emph{viii}- \code{Parent.pre}); and
\item the recall of child \code{T}-nodes by network inference (in \code{inferred.adjacency}), and the
related precision ( \emph{ix}- \code{Child.rec} and \emph{x}- \code{Child.pre}).
}

These 10 measures (\emph{i} - \emph{x}) are returned in a 10-column matrix named \code{raw.measures},
with one row for each found hub. If no parent or child node is found for a hub,
the corresponding measures are \code{NA}s.

The association measure used when \code{method} is a character is \link[ppcor]{pcor}.

A named function \code{combine.hubs} must be available in the calling environment,
and return a numeric scalar output for a numeric vector input. For two elements
\code{a} and \code{b}, \code{combine.hubs(c(a, b))} should be in the closed \code{[a, b]}.
This is checked for \code{a = 0} and \code{b = 1}, and the function stops if
this fails.
}
\examples{
## Describe hubs in the 'networkA11' data
library (MRGNgeneral)
data ('networkA11')
data ('confsetsA11')
data ('mrgninferA11')

# Using the average signal over parent/child nodes
Hubs <- describe.hubs (adjacency = networkA11$adjacency,
                       data = networkA11$data,
                       inferred.adjacency = mrgninferA11$adjacency,
                       conf.sets = confsetsA11,
                       n_t = 100, n_v = 100, n_q = 100, n_u = 200,
                       combine.nodes = mean,
                       combine.hubs = mean,
                       verbose = FALSE)
Hubs

# Using the maximum signal over parent/child nodes instead of the mean
Hubs <- describe.hubs (adjacency = networkA11$adjacency,
                       data = networkA11$data,
                       inferred.adjacency = mrgninferA11$adjacency,
                       conf.sets = confsetsA11,
                       n_t = 100, n_v = 100, n_q = 100, n_u = 200,
                       combine.nodes = max,
                       combine.hubs = mean,
                       verbose = FALSE)
Hubs
}
